#!/usr/bin/env python

import rospy
import threading
import sys, select, tty, termios

import numpy as np

from std_msgs.msg import String
from std_msgs.msg import Empty

from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Twist
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Point
from geometry_msgs.msg import Pose

from mpl_toolkits.mplot3d import Axes3D
from pid_controller import pd_controller
from copy import deepcopy
from transform_enhanced import get_yaw_from_quaternion

import state_manager
from route_manager import RouteManager

# All actuations and decisions are made in the main loop
# callback only renews the information used in the main loop
# main loop checks the state all the time and published according to
# the state that it sees.

# Key reading thread also may publish messages like landing and taking off.
# may also set desired altitude

ERROR_THRESHOLD = 0.1

TAKEOFF_HEIGHT = 0.5
DISTANCE_FROM_SHELF = 0.9

bebop_pose = None
bebop_yaw = 0.0
was_input_updated = False

controller_z = pd_controller(0.4, 10.0, 1.0) # global z, for copter looking at the shelf it is -x
controller_x = pd_controller(0.4, 12.0, 0.4) # global x, for copter looking at the shelf it is y (or -y) 
controller_y = pd_controller(1.0, 3.0, 0.7) # global y, for copter looking at the shelf it is z
controller_yaw = pd_controller(0.02, 0.0, 1.0) # global y, for copter looking at the shelf it is z
#controller_z.set_value_desired(0.9)
#controller_yaw.set_value_desired(0.0)

was_position_initial_set = False

#time_small_error = 0.0
#is_waypoint_reached = False

copter_state_manager = state_manager.StateManager()
route_manager = RouteManager()

class NonBlockingConsole(object):
    def __enter__(self):
        self.old_settings = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())
        return self

    def __exit__(self, type, value, traceback):
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)

    def get_data(self):
        try:
            if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
                return sys.stdin.read(1)
        except:
            return '[CTRL-C]'
        return False

def poseCallback(pose):
    global route_manager
    global bebop_pose, was_input_updated
    global bebop_yaw#, controller_yaw
    #global controller_x, controller_z, controller_z
    #global was_position_initial_set
    #global time_small_error, is_waypoint_reached
    time_current = rospy.get_time()

    bebop_pose = deepcopy(pose)
    was_input_updated = True
    bebop_yaw = get_yaw_from_quaternion(bebop_pose.orientation)

    #if not was_position_initial_set:
        #controller_x.set_value_desired(bebop_pose.position.x)
        #controller_y.set_value_desired(bebop_pose.position.y)
        #was_position_initial_set = True

    route_manager.set_current_position(bebop_pose.position, time_current)

    position_error = route_manager.get_current_error()
    position_error_publisher.publish(position_error)

def key_reader():
	global is_running
        global copter_state_manager
        global controller_y
	global is_keyreader_finished
	global speed_x, speed_y, speed_z, speed_yaw

	pub_takeoff = rospy.Publisher('bebop/takeoff', Empty, queue_size=10)
	pub_landing = rospy.Publisher('bebop/land', Empty, queue_size=10)
	message_empty = Empty()
	with NonBlockingConsole() as nbc:
		while is_running:
			c = nbc.get_data()
                        time_current = rospy.get_time()
                        if c == '\x1b': # x1b is ESC
				is_keyreader_finished = True
				pub_landing.publish(message_empty)
        	       		break
			elif c == '5':
                            speed_x = 0.0
                            speed_y = 0.0
                            speed_z = 0.0
                            speed_yaw = 0.0
                            print "zero position"
			elif c == 'l':
                            copter_state_manager.set_state(state_manager.COPTER_STATE_LANDING, time_current)
                            speed_x = 0.0
                            speed_y = 0.0
                            speed_z = 0.0
                            speed_yaw = 0.0
                            pub_landing.publish(message_empty)
                            print "land"
                        elif c == 'n':
                            print "navigate"
                            current_state = copter_state_manager.get_state(time_current)
                            if current_state == state_manager.COPTER_STATE_HOVERING:
                                copter_state_manager.set_state(state_manager.COPTER_STATE_NAVIGATING, time_current)
			elif c == 't':
                            #controller_y.set_value_desired(TAKEOFF_HEIGHT)
                            copter_state_manager.set_state(state_manager.COPTER_STATE_TAKING_OFF, time_current)
                            pub_takeoff.publish(message_empty)
                            print "take off"

def bebop_auto():
        global route_manager
        global copter_state_manager
	global is_keyreader_finished, is_landing
        global bebop_position, was_input_updated
        global speed_x, speed_y, speed_z, speed_yaw

	pub = rospy.Publisher('bebop/cmd_vel', Twist, queue_size = 10)
	rate = rospy.Rate(30)
        not_update_counter = 0
	while not rospy.is_shutdown() and not is_keyreader_finished:
            time_current = rospy.get_time()
            if was_input_updated: # if the input was updated, then we can do smth. what?
                                    # for all the controllers we can set new , and new current goal
                was_input_updated = False
                not_update_counter = 0

                if route_manager.is_route_finished() and \
                        copter_state_manager.get_state(time_current) == state_manager.COPTER_STATE_NAVIGATING:
                    copter_state_manager.set_state(state_manager.COPTER_STATE_HOVERING, time_current)
                    print("copter came to hovering state")
                else:
                    position_error = route_manager.get_current_error()
                    speed_x = controller_z.set_current_error(position_error.z)
                    speed_y = controller_x.set_current_error(position_error.x)
                    speed_z = -controller_y.set_current_error(position_error.y)
                    speed_yaw = controller_yaw.set_current_error(bebop_yaw)

            else:
                not_update_counter = not_update_counter + 1
                if not_update_counter >= 10:
                    speed_x = 0.0
                    speed_y = 0.0
                    speed_z = 0.0
                    speed_yaw = 0.0

            current_state = copter_state_manager.get_state(time_current)
            if current_state == state_manager.COPTER_STATE_NAVIGATING:
                twist_current = Twist(Vector3(speed_x, speed_y, speed_z), Vector3(0.0, 0.0, speed_yaw))
            else:
                twist_current = Twist(Vector3(0.0, 0.0, 0.0), Vector3(0.0, 0.0, 0.0))

            pub.publish(twist_current)
            rate.sleep()

if __name__ == '__main__':
    try:
	speed_x = 0.0
	speed_y = 0.0
	speed_z = 0.0
	speed_yaw = 0.0

	rospy.init_node('bebop_auto', anonymous = True)
        position_error_publisher = rospy.Publisher('bebop_position_error', Point, queue_size = 10)
        rospy.Subscriber("pose", Pose, poseCallback)
	is_running = True
	is_keyreader_finished = False
        is_landing = False
	thread_reader = threading.Thread(target = key_reader)
	thread_reader.start()
        bebop_auto()
	is_running = False
    except rospy.ROSInterruptException:
        pass
