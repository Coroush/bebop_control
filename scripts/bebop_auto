#!/usr/bin/env python

import rospy
import threading
import sys, select, tty, termios

import numpy as np

from std_msgs.msg import String
from std_msgs.msg import Empty
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Twist
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Point
from geometry_msgs.msg import Pose
from mpl_toolkits.mplot3d import Axes3D
from pid_controller import pd_controller
from copy import deepcopy
from transform_enhanced import get_yaw_from_quaternion

# All actuations and decisions are made in the main loop
# callback only renews the information used in the main loop
# main loop checks the state all the time and published according to
# the state that it sees.
# Key reading thread also may publish messages like landing and taking off.

ERROR_THRESHOLD = 0.1
TIME_POINT_REACHED = 1.0

bebop_pose = None
bebop_yaw = 0.0
was_input_updated = False

controller_z = pd_controller(0.4, 10.0, 1.0) # global z, for copter looking at the shelf it is -x
controller_x = pd_controller(0.4, 12.0, 1.0) # global x, for copter looking at the shelf it is y (or -y) 
controller_y = pd_controller(1.0, 3.0, 1.0) # global y, for copter looking at the shelf it is z
controller_yaw = pd_controller(0.02, 0.0, 1.0) # global y, for copter looking at the shelf it is z
controller_z.set_value_desired(0.9)
controller_yaw.set_value_desired(0.0)

was_position_desired_set = False

y_desired_list = [0.7, 1.2, 1.8]
y_list_index = 0

x_desired_list = [-1.7, -1.4, -1.1]
x_list_index = 0

time_small_error = 0.0
is_waypoint_reached = False

def switch_y_index():
    global y_list_index
    y_list_index +=  1
    if y_list_index >= len(y_desired_list):
        y_list_index = 0

def switch_x_index():
    global x_list_index
    x_list_index +=  1
    if x_list_index >= len(x_desired_list):
        x_list_index = 0

class NonBlockingConsole(object):
    def __enter__(self):
        self.old_settings = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())
        return self

    def __exit__(self, type, value, traceback):
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)

    def get_data(self):
        try:
            if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
                return sys.stdin.read(1)
        except:
            return '[CTRL-C]'
        return False

def poseCallback(pose):
    global bebop_pose, was_input_updated
    global bebop_yaw, controller_yaw
    global controller_x, controller_z, controller_z
    global was_position_desired_set
    global time_small_error, is_waypoint_reached

    bebop_pose = deepcopy(pose)
    was_input_updated = True
    bebop_yaw = get_yaw_from_quaternion(bebop_pose.orientation)

    if not was_position_desired_set:
        controller_x.set_value_desired(bebop_pose.position.x)
        controller_y.set_value_desired(bebop_pose.position.y)
        was_position_desired_set = True

    x_error = controller_x.get_error()
    y_error = controller_y.get_error()
    z_error = controller_z.get_error()

    if np.abs(x_error) < ERROR_THRESHOLD and \
            np.abs(y_error) < ERROR_THRESHOLD and \
            np.abs(z_error) < ERROR_THRESHOLD:
        if is_waypoint_reached:
            pass
        else:
            time_current = rospy.get_time()
            time_difference = time_current - time_small_error
            if time_difference > TIME_POINT_REACHED:
                is_waypoint_reached = True
                print("waypoint was reached")
    else:
        time_small_error = rospy.get_time()
        is_waypoint_reached = False

    position_error_publisher.publish(Point(x_error, \
            y_error, \
            z_error))

def key_reader():
	global is_running, is_landing
        global controller_z
	global twist_current
	global is_keyreader_finished
	global speed_x, speed_y, speed_z, speed_yaw
        global y_list_index

	pub_takeoff = rospy.Publisher('bebop/takeoff', Empty, queue_size=10)
	pub_landing = rospy.Publisher('bebop/land', Empty, queue_size=10)
	message_empty = Empty()
	with NonBlockingConsole() as nbc:
		while is_running:
			c = nbc.get_data()
                        if c == '\x1b': # x1b is ESC
				is_keyreader_finished = True
				pub_landing.publish(message_empty)
        	       		break
			elif c == '5':
				speed_x = 0.0
				speed_y = 0.0
				speed_z = 0.0
				speed_yaw = 0.0
				twist_current = Twist(Vector3(speed_x, speed_y, speed_z), \
                                        Vector3(0.0, 0.0, speed_yaw))
        	        	print "zero position"
			elif c == 'l':
                                is_landing = True
				speed_x = 0.0
				speed_y = 0.0
				speed_z = 0.0
				speed_yaw = 0.0
				twist_current = Twist(Vector3(speed_x, speed_y, speed_z), \
                                        Vector3(0.0, 0.0, speed_yaw))
				pub_landing.publish(message_empty)
        	        	print "land"
                        elif c == 's':
                            controller_y.set_value_desired(y_desired_list[y_list_index])
                            print "desired z was changed to " + str(y_desired_list[y_list_index])
                            switch_y_index()
                        elif c == 'x':
                            controller_x.set_value_desired(x_desired_list[x_list_index])
                            print "desired x was changed to " + str(x_desired_list[x_list_index])
                            switch_x_index()
			elif c == 't':
                            y_list_index = 0
                            controller_y.set_value_desired(y_desired_list[y_list_index])
                            print "with taking off desired z was changed to " + str(y_desired_list[y_list_index])
                            switch_y_index()
                            is_landing = False
                            pub_takeoff.publish(message_empty)
                            print "take off"

def bebop_auto():
	global twist_current
	global is_keyreader_finished, is_landing
        global bebop_position, was_input_updated
        global speed_x, speed_y, speed_z, speed_yaw

	pub = rospy.Publisher('bebop/cmd_vel', Twist, queue_size = 10)
	rate = rospy.Rate(30)
        not_update_counter = 0
	while not rospy.is_shutdown() and not is_keyreader_finished:
            if was_input_updated:
                was_input_updated = False
                not_update_counter = 0
                speed_x = -controller_z.set_value_current(bebop_pose.position.z)
                speed_y = -controller_x.set_value_current(bebop_pose.position.x)
                speed_z = controller_y.set_value_current(bebop_pose.position.y)
                speed_yaw = -controller_yaw.set_value_current(bebop_yaw)

            else:
                not_update_counter = not_update_counter + 1
                if not_update_counter >= 10:
                    speed_x = 0.0
                    speed_y = 0.0
                    speed_z = 0.0
                    speed_yaw = 0.0

            if not is_landing:
                twist_current = Twist(Vector3(speed_x, speed_y, speed_z), Vector3(0.0, 0.0, speed_yaw))
	        pub.publish(twist_current)
            rate.sleep()

if __name__ == '__main__':
    try:
	speed_x = 0.0
	speed_y = 0.0
	speed_z = 0.0
	speed_yaw = 0.0

	rospy.init_node('bebop_auto', anonymous = True)
        position_error_publisher = rospy.Publisher('bebop_position_error', Point, queue_size = 10)
        rospy.Subscriber("pose", Pose, poseCallback)
	twist_current = Twist(Vector3(0, 0, 0), Vector3(0, 0, 0))
	is_running = True
	is_keyreader_finished = False
        is_landing = False
	thread_reader = threading.Thread(target = key_reader)
	thread_reader.start()
        bebop_auto()
	is_running = False
    except rospy.ROSInterruptException:
        pass
